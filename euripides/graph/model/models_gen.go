// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type MetricsAggRow interface {
	IsMetricsAggRow()
	GetDocCount() int32
	GetSampleCount() *int32
	GetCPU() *MetricStats
	GetMem() *MetricStats
}

type TraceItemPayload interface {
	IsTraceItemPayload()
}

type ActionEvent struct {
	Action *string `json:"action,omitempty"`
	Status *string `json:"status,omitempty"`
	TookMs *int32  `json:"tookMs,omitempty"`
}

func (ActionEvent) IsTraceItemPayload() {}

type DatabaseSpanEvent struct {
	Action *string `json:"action,omitempty"`
	Query  *string `json:"query,omitempty"`
	Hits   *int32  `json:"hits,omitempty"`
	TookMs *int32  `json:"tookMs,omitempty"`
}

func (DatabaseSpanEvent) IsTraceItemPayload() {}

type EnqueueItems struct {
	Traces    []*TraceSummary `json:"traces"`
	UpdatedAt string          `json:"updatedAt"`
}

type GraphQLEvent struct {
	Operation *string `json:"operation,omitempty"`
	RootQuery *string `json:"rootQuery,omitempty"`
}

func (GraphQLEvent) IsTraceItemPayload() {}

type MetricPoint struct {
	Timestamp    string        `json:"timestamp"`
	BucketMs     *int32        `json:"bucketMs,omitempty"`
	Count        *int32        `json:"count,omitempty"`
	CPUMCoresAvg *float64      `json:"cpuMCoresAvg,omitempty"`
	CPUMCoresMax *float64      `json:"cpuMCoresMax,omitempty"`
	CPUMCoresP95 *float64      `json:"cpuMCoresP95,omitempty"`
	MemBytesAvg  *float64      `json:"memBytesAvg,omitempty"`
	MemBytesMax  *float64      `json:"memBytesMax,omitempty"`
	MemBytesP95  *float64      `json:"memBytesP95,omitempty"`
	Source       *MetricSource `json:"source,omitempty"`
}

type MetricScopeInput struct {
	Node      *string `json:"node,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	PodName   *string `json:"podName,omitempty"`
	PodUID    *string `json:"podUID,omitempty"`
}

type MetricSeries struct {
	Label  *MetricSeriesLabel `json:"label"`
	Points []*MetricPoint     `json:"points"`
}

type MetricSeriesLabel struct {
	Node      *string `json:"node,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	PodName   *string `json:"podName,omitempty"`
	PodUID    *string `json:"podUID,omitempty"`
}

type MetricSeriesPage struct {
	Total int32           `json:"total"`
	Items []*MetricSeries `json:"items"`
}

type MetricSource struct {
	Aggregator    *string `json:"aggregator,omitempty"`
	Collector     *string `json:"collector,omitempty"`
	Method        *string `json:"method,omitempty"`
	WindowKind    *string `json:"windowKind,omitempty"`
	WindowSamples *int32  `json:"windowSamples,omitempty"`
}

type MetricStats struct {
	Avg           *float64 `json:"avg,omitempty"`
	Max           *float64 `json:"max,omitempty"`
	P95           *float64 `json:"p95,omitempty"`
	AvgHuman      *string  `json:"avgHuman,omitempty"`
	MaxHuman      *string  `json:"maxHuman,omitempty"`
	P95Human      *string  `json:"p95Human,omitempty"`
	TotalMax      *float64 `json:"totalMax,omitempty"`
	TotalMaxHuman *string  `json:"totalMaxHuman,omitempty"`
}

type MetricsGroupNamespace struct {
	Total int32                  `json:"total"`
	Items []*NamespaceMetricsAgg `json:"items"`
}

type MetricsGroupNode struct {
	Total int32             `json:"total"`
	Items []*NodeMetricsAgg `json:"items"`
}

type MetricsGroupPod struct {
	Total int32            `json:"total"`
	Items []*PodMetricsAgg `json:"items"`
}

// Top-level “overview for a time window”.
// Everything is aggregated over the selected window.
type MetricsSummary struct {
	Window     MetricsWindow          `json:"window"`
	Start      string                 `json:"start"`
	End        string                 `json:"end"`
	Nodes      *MetricsGroupNode      `json:"nodes"`
	Namespaces *MetricsGroupNamespace `json:"namespaces"`
	Pods       *MetricsGroupPod       `json:"pods"`
}

type MetricsSummaryInput struct {
	Window MetricsWindow `json:"window"`
}

type NamespaceMetricsAgg struct {
	Namespace   string       `json:"namespace"`
	DocCount    int32        `json:"docCount"`
	SampleCount *int32       `json:"sampleCount,omitempty"`
	CPU         *MetricStats `json:"cpu"`
	Mem         *MetricStats `json:"mem"`
	SortKey     *float64     `json:"sortKey,omitempty"`
}

func (NamespaceMetricsAgg) IsMetricsAggRow()            {}
func (this NamespaceMetricsAgg) GetDocCount() int32     { return this.DocCount }
func (this NamespaceMetricsAgg) GetSampleCount() *int32 { return this.SampleCount }
func (this NamespaceMetricsAgg) GetCPU() *MetricStats   { return this.CPU }
func (this NamespaceMetricsAgg) GetMem() *MetricStats   { return this.Mem }

type NodeMetricsAgg struct {
	Node        string       `json:"node"`
	DocCount    int32        `json:"docCount"`
	SampleCount *int32       `json:"sampleCount,omitempty"`
	CPU         *MetricStats `json:"cpu"`
	Mem         *MetricStats `json:"mem"`
	SortKey     *float64     `json:"sortKey,omitempty"`
}

func (NodeMetricsAgg) IsMetricsAggRow()            {}
func (this NodeMetricsAgg) GetDocCount() int32     { return this.DocCount }
func (this NodeMetricsAgg) GetSampleCount() *int32 { return this.SampleCount }
func (this NodeMetricsAgg) GetCPU() *MetricStats   { return this.CPU }
func (this NodeMetricsAgg) GetMem() *MetricStats   { return this.Mem }

type PaginationInput struct {
	Limit  *int32 `json:"limit,omitempty"`
	Offset *int32 `json:"offset,omitempty"`
}

type PodMetricsAgg struct {
	PodName     string       `json:"podName"`
	Namespace   *string      `json:"namespace,omitempty"`
	Node        *string      `json:"node,omitempty"`
	DocCount    int32        `json:"docCount"`
	SampleCount *int32       `json:"sampleCount,omitempty"`
	CPU         *MetricStats `json:"cpu"`
	Mem         *MetricStats `json:"mem"`
	SortKey     *float64     `json:"sortKey,omitempty"`
}

func (PodMetricsAgg) IsMetricsAggRow()            {}
func (this PodMetricsAgg) GetDocCount() int32     { return this.DocCount }
func (this PodMetricsAgg) GetSampleCount() *int32 { return this.SampleCount }
func (this PodMetricsAgg) GetCPU() *MetricStats   { return this.CPU }
func (this PodMetricsAgg) GetMem() *MetricStats   { return this.Mem }

type Query struct {
}

type RawMetricsInput struct {
	PodName   *string `json:"podName,omitempty"`
	TimeStamp *string `json:"timeStamp,omitempty"`
}

type TimeRangeInput struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type Trace struct {
	ID           string       `json:"id"`
	IsActive     bool         `json:"isActive"`
	TimeStarted  string       `json:"timeStarted"`
	TimeEnded    *string      `json:"timeEnded,omitempty"`
	TotalTimeMs  int32        `json:"totalTimeMs"`
	ResponseCode int32        `json:"responseCode"`
	Namespace    *string      `json:"namespace,omitempty"`
	PodName      *string      `json:"podName,omitempty"`
	Operation    *string      `json:"operation,omitempty"`
	HasDbSpan    bool         `json:"hasDbSpan"`
	HasAction    bool         `json:"hasAction"`
	Items        []*TraceItem `json:"items"`
}

type TraceHopEvent struct {
	Method *string `json:"method,omitempty"`
	URL    *string `json:"url,omitempty"`
	Host   *string `json:"host,omitempty"`
}

func (TraceHopEvent) IsTraceItemPayload() {}

type TraceHopStopEvent struct {
	ResponseCode *int32 `json:"responseCode,omitempty"`
	TookMs       *int32 `json:"tookMs,omitempty"`
}

func (TraceHopStopEvent) IsTraceItemPayload() {}

type TraceItem struct {
	Timestamp    string           `json:"timestamp"`
	ItemType     TraceItemType    `json:"itemType"`
	SpanID       *string          `json:"spanId,omitempty"`
	ParentSpanID *string          `json:"parentSpanId,omitempty"`
	PodName      *string          `json:"podName,omitempty"`
	Namespace    *string          `json:"namespace,omitempty"`
	Payload      TraceItemPayload `json:"payload,omitempty"`
}

type TracePage struct {
	Total int32           `json:"total"`
	Items []*TraceSummary `json:"items"`
}

type TraceSearchInput struct {
	Window              TraceWindow `json:"window"`
	Limit               *int32      `json:"limit,omitempty"`
	ResponseCode        *int32      `json:"responseCode,omitempty"`
	TimeTookGreaterThan *int32      `json:"timeTookGreaterThan,omitempty"`
	Operation           *string     `json:"operation,omitempty"`
}

type TraceStartEvent struct {
	Method        *string `json:"method,omitempty"`
	URL           *string `json:"url,omitempty"`
	Host          *string `json:"host,omitempty"`
	RemoteAddress *string `json:"remoteAddress,omitempty"`
	RootQuery     *string `json:"rootQuery,omitempty"`
	Operation     *string `json:"operation,omitempty"`
}

func (TraceStartEvent) IsTraceItemPayload() {}

type TraceStopEvent struct {
	ResponseBody *string `json:"responseBody,omitempty"`
}

func (TraceStopEvent) IsTraceItemPayload() {}

type TraceSummary struct {
	ID            string  `json:"id"`
	IsActive      bool    `json:"isActive"`
	HasDbSpan     bool    `json:"hasDbSpan"`
	TimeStarted   *string `json:"timeStarted,omitempty"`
	TimeEnded     *string `json:"timeEnded,omitempty"`
	RootQuery     string  `json:"rootQuery"`
	TotalTimeMs   int32   `json:"totalTimeMs"`
	ResponseCode  int32   `json:"responseCode"`
	NumberOfItems int32   `json:"numberOfItems"`
}

type MetricGroupBy string

const (
	MetricGroupByNone        MetricGroupBy = "NONE"
	MetricGroupByByNode      MetricGroupBy = "BY_NODE"
	MetricGroupByByNamespace MetricGroupBy = "BY_NAMESPACE"
	MetricGroupByByPod       MetricGroupBy = "BY_POD"
)

var AllMetricGroupBy = []MetricGroupBy{
	MetricGroupByNone,
	MetricGroupByByNode,
	MetricGroupByByNamespace,
	MetricGroupByByPod,
}

func (e MetricGroupBy) IsValid() bool {
	switch e {
	case MetricGroupByNone, MetricGroupByByNode, MetricGroupByByNamespace, MetricGroupByByPod:
		return true
	}
	return false
}

func (e MetricGroupBy) String() string {
	return string(e)
}

func (e *MetricGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricGroupBy", str)
	}
	return nil
}

func (e MetricGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricOrderBy string

const (
	MetricOrderByCPUAvg MetricOrderBy = "CPU_AVG"
	MetricOrderByCPUMax MetricOrderBy = "CPU_MAX"
	MetricOrderByMemAvg MetricOrderBy = "MEM_AVG"
	MetricOrderByMemMax MetricOrderBy = "MEM_MAX"
)

var AllMetricOrderBy = []MetricOrderBy{
	MetricOrderByCPUAvg,
	MetricOrderByCPUMax,
	MetricOrderByMemAvg,
	MetricOrderByMemMax,
}

func (e MetricOrderBy) IsValid() bool {
	switch e {
	case MetricOrderByCPUAvg, MetricOrderByCPUMax, MetricOrderByMemAvg, MetricOrderByMemMax:
		return true
	}
	return false
}

func (e MetricOrderBy) String() string {
	return string(e)
}

func (e *MetricOrderBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricOrderBy", str)
	}
	return nil
}

func (e MetricOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricOrderBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricOrderBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricResolution string

const (
	MetricResolutionAuto   MetricResolution = "AUTO"
	MetricResolutionRaw    MetricResolution = "RAW"
	MetricResolutionRollup MetricResolution = "ROLLUP"
)

var AllMetricResolution = []MetricResolution{
	MetricResolutionAuto,
	MetricResolutionRaw,
	MetricResolutionRollup,
}

func (e MetricResolution) IsValid() bool {
	switch e {
	case MetricResolutionAuto, MetricResolutionRaw, MetricResolutionRollup:
		return true
	}
	return false
}

func (e MetricResolution) String() string {
	return string(e)
}

func (e *MetricResolution) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricResolution(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricResolution", str)
	}
	return nil
}

func (e MetricResolution) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricResolution) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricResolution) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricsWindow string

const (
	MetricsWindowM10 MetricsWindow = "M10"
	MetricsWindowM30 MetricsWindow = "M30"
	MetricsWindowH1  MetricsWindow = "H1"
	MetricsWindowH2  MetricsWindow = "H2"
	MetricsWindowH12 MetricsWindow = "H12"
	MetricsWindowH24 MetricsWindow = "H24"
)

var AllMetricsWindow = []MetricsWindow{
	MetricsWindowM10,
	MetricsWindowM30,
	MetricsWindowH1,
	MetricsWindowH2,
	MetricsWindowH12,
	MetricsWindowH24,
}

func (e MetricsWindow) IsValid() bool {
	switch e {
	case MetricsWindowM10, MetricsWindowM30, MetricsWindowH1, MetricsWindowH2, MetricsWindowH12, MetricsWindowH24:
		return true
	}
	return false
}

func (e MetricsWindow) String() string {
	return string(e)
}

func (e *MetricsWindow) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricsWindow(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricsWindow", str)
	}
	return nil
}

func (e MetricsWindow) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricsWindow) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricsWindow) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceItemType string

const (
	TraceItemTypeTraceStart   TraceItemType = "TRACE_START"
	TraceItemTypeTraceHop     TraceItemType = "TRACE_HOP"
	TraceItemTypeGraphql      TraceItemType = "GRAPHQL"
	TraceItemTypeAction       TraceItemType = "ACTION"
	TraceItemTypeDbSpan       TraceItemType = "DB_SPAN"
	TraceItemTypeTraceStop    TraceItemType = "TRACE_STOP"
	TraceItemTypeTraceHopStop TraceItemType = "TRACE_HOP_STOP"
)

var AllTraceItemType = []TraceItemType{
	TraceItemTypeTraceStart,
	TraceItemTypeTraceHop,
	TraceItemTypeGraphql,
	TraceItemTypeAction,
	TraceItemTypeDbSpan,
	TraceItemTypeTraceStop,
	TraceItemTypeTraceHopStop,
}

func (e TraceItemType) IsValid() bool {
	switch e {
	case TraceItemTypeTraceStart, TraceItemTypeTraceHop, TraceItemTypeGraphql, TraceItemTypeAction, TraceItemTypeDbSpan, TraceItemTypeTraceStop, TraceItemTypeTraceHopStop:
		return true
	}
	return false
}

func (e TraceItemType) String() string {
	return string(e)
}

func (e *TraceItemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceItemType", str)
	}
	return nil
}

func (e TraceItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceItemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceItemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceOrderBy string

const (
	TraceOrderByTimeStarted  TraceOrderBy = "TIME_STARTED"
	TraceOrderByTimeEnded    TraceOrderBy = "TIME_ENDED"
	TraceOrderByTotalTimeMs  TraceOrderBy = "TOTAL_TIME_MS"
	TraceOrderByResponseCode TraceOrderBy = "RESPONSE_CODE"
)

var AllTraceOrderBy = []TraceOrderBy{
	TraceOrderByTimeStarted,
	TraceOrderByTimeEnded,
	TraceOrderByTotalTimeMs,
	TraceOrderByResponseCode,
}

func (e TraceOrderBy) IsValid() bool {
	switch e {
	case TraceOrderByTimeStarted, TraceOrderByTimeEnded, TraceOrderByTotalTimeMs, TraceOrderByResponseCode:
		return true
	}
	return false
}

func (e TraceOrderBy) String() string {
	return string(e)
}

func (e *TraceOrderBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceOrderBy", str)
	}
	return nil
}

func (e TraceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceOrderBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceOrderBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceWindow string

const (
	TraceWindowM5  TraceWindow = "M5"
	TraceWindowM10 TraceWindow = "M10"
	TraceWindowM30 TraceWindow = "M30"
	TraceWindowH1  TraceWindow = "H1"
	TraceWindowH2  TraceWindow = "H2"
	TraceWindowH12 TraceWindow = "H12"
	TraceWindowH24 TraceWindow = "H24"
)

var AllTraceWindow = []TraceWindow{
	TraceWindowM5,
	TraceWindowM10,
	TraceWindowM30,
	TraceWindowH1,
	TraceWindowH2,
	TraceWindowH12,
	TraceWindowH24,
}

func (e TraceWindow) IsValid() bool {
	switch e {
	case TraceWindowM5, TraceWindowM10, TraceWindowM30, TraceWindowH1, TraceWindowH2, TraceWindowH12, TraceWindowH24:
		return true
	}
	return false
}

func (e TraceWindow) String() string {
	return string(e)
}

func (e *TraceWindow) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceWindow(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceWindow", str)
	}
	return nil
}

func (e TraceWindow) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceWindow) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceWindow) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
