// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type TraceItemPayload interface {
	IsTraceItemPayload()
}

type ActionEvent struct {
	Action *string `json:"action,omitempty"`
	Status *string `json:"status,omitempty"`
	TookMs *int32  `json:"tookMs,omitempty"`
}

func (ActionEvent) IsTraceItemPayload() {}

type DatabaseSpanEvent struct {
	Action *string `json:"action,omitempty"`
	Query  *string `json:"query,omitempty"`
	Hits   *int32  `json:"hits,omitempty"`
	TookMs *int32  `json:"tookMs,omitempty"`
	Target *string `json:"target,omitempty"`
	Index  *string `json:"index,omitempty"`
}

func (DatabaseSpanEvent) IsTraceItemPayload() {}

type GraphQLEvent struct {
	Operation *string `json:"operation,omitempty"`
	RootQuery *string `json:"rootQuery,omitempty"`
}

func (GraphQLEvent) IsTraceItemPayload() {}

type MetricPoint struct {
	Timestamp    string        `json:"timestamp"`
	BucketMs     *int32        `json:"bucketMs,omitempty"`
	Count        *int32        `json:"count,omitempty"`
	CPUMCoresAvg *float64      `json:"cpuMCoresAvg,omitempty"`
	CPUMCoresMax *float64      `json:"cpuMCoresMax,omitempty"`
	CPUMCoresP95 *float64      `json:"cpuMCoresP95,omitempty"`
	MemBytesAvg  *float64      `json:"memBytesAvg,omitempty"`
	MemBytesMax  *float64      `json:"memBytesMax,omitempty"`
	MemBytesP95  *float64      `json:"memBytesP95,omitempty"`
	Source       *MetricSource `json:"source,omitempty"`
}

type MetricScopeInput struct {
	Node      *string `json:"node,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	PodName   *string `json:"podName,omitempty"`
	PodUID    *string `json:"podUID,omitempty"`
}

type MetricSeries struct {
	Label  *MetricSeriesLabel `json:"label"`
	Points []*MetricPoint     `json:"points"`
}

type MetricSeriesLabel struct {
	Node      *string `json:"node,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	PodName   *string `json:"podName,omitempty"`
	PodUID    *string `json:"podUID,omitempty"`
}

type MetricSeriesPage struct {
	Total int32           `json:"total"`
	Items []*MetricSeries `json:"items"`
}

type MetricSource struct {
	Aggregator    *string `json:"aggregator,omitempty"`
	Collector     *string `json:"collector,omitempty"`
	Method        *string `json:"method,omitempty"`
	WindowKind    *string `json:"windowKind,omitempty"`
	WindowSamples *int32  `json:"windowSamples,omitempty"`
}

type PaginationInput struct {
	Limit  *int32 `json:"limit,omitempty"`
	Offset *int32 `json:"offset,omitempty"`
}

type Query struct {
}

type TimeRangeInput struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type Trace struct {
	ID           string       `json:"id"`
	IsActive     bool         `json:"isActive"`
	TimeStarted  string       `json:"timeStarted"`
	TimeEnded    *string      `json:"timeEnded,omitempty"`
	TotalTimeMs  int32        `json:"totalTimeMs"`
	ResponseCode int32        `json:"responseCode"`
	Namespace    *string      `json:"namespace,omitempty"`
	PodName      *string      `json:"podName,omitempty"`
	Operation    *string      `json:"operation,omitempty"`
	HasDbSpan    bool         `json:"hasDbSpan"`
	HasAction    bool         `json:"hasAction"`
	Items        []*TraceItem `json:"items"`
}

type TraceFilterInput struct {
	Namespace      *string `json:"namespace,omitempty"`
	PodName        *string `json:"podName,omitempty"`
	Operation      *string `json:"operation,omitempty"`
	HasDbSpan      *bool   `json:"hasDbSpan,omitempty"`
	HasAction      *bool   `json:"hasAction,omitempty"`
	MinTotalTimeMs *int32  `json:"minTotalTimeMs,omitempty"`
	MaxTotalTimeMs *int32  `json:"maxTotalTimeMs,omitempty"`
	ResponseCode   *int32  `json:"responseCode,omitempty"`
}

type TraceHopEvent struct {
	Method       *string `json:"method,omitempty"`
	URL          *string `json:"url,omitempty"`
	Host         *string `json:"host,omitempty"`
	ResponseCode *int32  `json:"responseCode,omitempty"`
	TookMs       *int32  `json:"tookMs,omitempty"`
}

func (TraceHopEvent) IsTraceItemPayload() {}

type TraceItem struct {
	Timestamp    string           `json:"timestamp"`
	ItemType     TraceItemType    `json:"itemType"`
	SpanID       *string          `json:"spanId,omitempty"`
	ParentSpanID *string          `json:"parentSpanId,omitempty"`
	PodName      *string          `json:"podName,omitempty"`
	Namespace    *string          `json:"namespace,omitempty"`
	Payload      TraceItemPayload `json:"payload"`
}

type TracePage struct {
	Total int32    `json:"total"`
	Items []*Trace `json:"items"`
}

type TraceStartEvent struct {
	Method        *string `json:"method,omitempty"`
	URL           *string `json:"url,omitempty"`
	Host          *string `json:"host,omitempty"`
	RemoteAddress *string `json:"remoteAddress,omitempty"`
	RootQuery     *string `json:"rootQuery,omitempty"`
	Operation     *string `json:"operation,omitempty"`
}

func (TraceStartEvent) IsTraceItemPayload() {}

type TraceStopEvent struct {
	ResponseBody *string `json:"responseBody,omitempty"`
}

func (TraceStopEvent) IsTraceItemPayload() {}

type MetricGroupBy string

const (
	MetricGroupByNone        MetricGroupBy = "NONE"
	MetricGroupByByNode      MetricGroupBy = "BY_NODE"
	MetricGroupByByNamespace MetricGroupBy = "BY_NAMESPACE"
	MetricGroupByByPod       MetricGroupBy = "BY_POD"
)

var AllMetricGroupBy = []MetricGroupBy{
	MetricGroupByNone,
	MetricGroupByByNode,
	MetricGroupByByNamespace,
	MetricGroupByByPod,
}

func (e MetricGroupBy) IsValid() bool {
	switch e {
	case MetricGroupByNone, MetricGroupByByNode, MetricGroupByByNamespace, MetricGroupByByPod:
		return true
	}
	return false
}

func (e MetricGroupBy) String() string {
	return string(e)
}

func (e *MetricGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricGroupBy", str)
	}
	return nil
}

func (e MetricGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricOrderBy string

const (
	MetricOrderByCPUAvg MetricOrderBy = "CPU_AVG"
	MetricOrderByCPUMax MetricOrderBy = "CPU_MAX"
	MetricOrderByMemAvg MetricOrderBy = "MEM_AVG"
	MetricOrderByMemMax MetricOrderBy = "MEM_MAX"
)

var AllMetricOrderBy = []MetricOrderBy{
	MetricOrderByCPUAvg,
	MetricOrderByCPUMax,
	MetricOrderByMemAvg,
	MetricOrderByMemMax,
}

func (e MetricOrderBy) IsValid() bool {
	switch e {
	case MetricOrderByCPUAvg, MetricOrderByCPUMax, MetricOrderByMemAvg, MetricOrderByMemMax:
		return true
	}
	return false
}

func (e MetricOrderBy) String() string {
	return string(e)
}

func (e *MetricOrderBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricOrderBy", str)
	}
	return nil
}

func (e MetricOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricOrderBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricOrderBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetricResolution string

const (
	MetricResolutionAuto   MetricResolution = "AUTO"
	MetricResolutionRaw    MetricResolution = "RAW"
	MetricResolutionRollup MetricResolution = "ROLLUP"
)

var AllMetricResolution = []MetricResolution{
	MetricResolutionAuto,
	MetricResolutionRaw,
	MetricResolutionRollup,
}

func (e MetricResolution) IsValid() bool {
	switch e {
	case MetricResolutionAuto, MetricResolutionRaw, MetricResolutionRollup:
		return true
	}
	return false
}

func (e MetricResolution) String() string {
	return string(e)
}

func (e *MetricResolution) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetricResolution(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetricResolution", str)
	}
	return nil
}

func (e MetricResolution) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetricResolution) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetricResolution) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceItemType string

const (
	TraceItemTypeTraceStart TraceItemType = "TRACE_START"
	TraceItemTypeTraceHop   TraceItemType = "TRACE_HOP"
	TraceItemTypeGraphql    TraceItemType = "GRAPHQL"
	TraceItemTypeAction     TraceItemType = "ACTION"
	TraceItemTypeDbSpan     TraceItemType = "DB_SPAN"
	TraceItemTypeTraceStop  TraceItemType = "TRACE_STOP"
)

var AllTraceItemType = []TraceItemType{
	TraceItemTypeTraceStart,
	TraceItemTypeTraceHop,
	TraceItemTypeGraphql,
	TraceItemTypeAction,
	TraceItemTypeDbSpan,
	TraceItemTypeTraceStop,
}

func (e TraceItemType) IsValid() bool {
	switch e {
	case TraceItemTypeTraceStart, TraceItemTypeTraceHop, TraceItemTypeGraphql, TraceItemTypeAction, TraceItemTypeDbSpan, TraceItemTypeTraceStop:
		return true
	}
	return false
}

func (e TraceItemType) String() string {
	return string(e)
}

func (e *TraceItemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceItemType", str)
	}
	return nil
}

func (e TraceItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceItemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceItemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TraceOrderBy string

const (
	TraceOrderByTimeStarted  TraceOrderBy = "TIME_STARTED"
	TraceOrderByTimeEnded    TraceOrderBy = "TIME_ENDED"
	TraceOrderByTotalTimeMs  TraceOrderBy = "TOTAL_TIME_MS"
	TraceOrderByResponseCode TraceOrderBy = "RESPONSE_CODE"
)

var AllTraceOrderBy = []TraceOrderBy{
	TraceOrderByTimeStarted,
	TraceOrderByTimeEnded,
	TraceOrderByTotalTimeMs,
	TraceOrderByResponseCode,
}

func (e TraceOrderBy) IsValid() bool {
	switch e {
	case TraceOrderByTimeStarted, TraceOrderByTimeEnded, TraceOrderByTotalTimeMs, TraceOrderByResponseCode:
		return true
	}
	return false
}

func (e TraceOrderBy) String() string {
	return string(e)
}

func (e *TraceOrderBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TraceOrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TraceOrderBy", str)
	}
	return nil
}

func (e TraceOrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TraceOrderBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TraceOrderBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
